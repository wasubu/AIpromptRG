--- START OF FILE Retrogadget Lua Scripting Cheat Sheet v17.txt ---

Retrogadget Lua Scripting Cheat Sheet (v17 - Precise Colors & Final Details)

**Goal:** To provide reliable guidelines for generating Lua code compatible with the Retrogadget environment, based on documentation, confirmed working examples, and direct testing.

**Environment:**

*   **Engine:** Retrogadget Game
*   **Language:** Luau (based on Lua 5.1 syntax, with specific extensions detailed below).
*   **Execution Context:** Scripts run attached to a Lua Controller component.

**Core Script Structure & Execution:**

1.  **Main Script File:** Code resides in a Lua script file.
2.  **Execution Flow:**
    *   **Top Level:** Code runs **once** on script load / simulation start. Used for `require`, constants, initial definitions.
    *   **`onInit()`:** Optional callback function. Called **once** automatically ONLY on initial script load / simulation start (after top-level code). Good for setup needing component access. **Does NOT run when powering on via a PowerButton component.**
    *   **`update()`:** Optional callback function. Called **repeatedly** every frame while the gadget simulation is running and powered (if applicable). Main loop for logic, input, drawing.
    *   **`eventChannelN(sender, arg)`:** Optional callback functions. Called automatically when data arrives on the corresponding input channel of the Lua Controller (configured in the editor, e.g., from Wifi, KeyboardChip, GamepadChip).
3.  **Power-On Logic (with PowerButton):** To run code specifically when a gadget is powered *on* using a `PowerButton`, check for state changes of `gdt.PowerButtonN.PowerState` within the `update()` loop.

**Accessing Gadget Components (`gdt`):**

*   Components accessed via global `gdt` table.
*   Reference by **editor name** (case-sensitive, e.g., `gdt.VideoChip0`, `gdt.Wifi0`, `gdt.FlashMemory0`).
    *   **Exception:** `LcdDisplay` components are referenced as `gdt.LcdN` (e.g., `gdt.Lcd0`).
*   **Component Discovery:** Use `pairs(gdt)` to iterate over attached components.
*   **Documented Component Types (Examples):** Input (AnalogStick, DPad, LedButton...), Output (LcdDisplay, Led, Screen...), Misc (AudioChip, CPU, ROM, VideoChip, Wifi, FlashMemory...).
*   **Direct Property Access:** Use dot notation (e.g., `.Value`, `.Text`, `.LedState`, `.AccessDenied`, `.Usage`).
*   **Methods:** Use colon notation (e.g., `_vc:Clear()`, `fm:Save()`).

**Common Component APIs:**

*   **`VideoChipN`:** See **Drawing**. `.Width`, `.Height`.
*   **`SliderN`:** `.Value` (0-100).
*   **`ButtonN`/`LedButtonN`:** `.ButtonState` (held), `.ButtonDown` (pressed this frame), `.LedState` (read/write boolean).
*   **`DPadN`:** `.X`, `.Y` (-100, 0, 100).
*   **`CPUN`:** `.DeltaTime`, `.Time`.
*   **`AudioChipN`:** `:SetChannelVolume()`, `:Play()`, `:IsPlaying()`.
*   **`LcdN`:** **(LcdDisplay type)** `.Text` (write).
*   **`ScreenN`:** `.Width`, `.Height`, `.Offset`.
*   **`WifiN`:** See **Networking**. `.AccessDenied` (read-only boolean).
*   **`FlashMemoryN`:** See **Persistence**. `.Size` (bytes, read-only), `.Usage` (bytes, read-only).
*   **`PowerButtonN`:** `.PowerState` (boolean, read-only).

**Time & Frame Rate:**

*   Use `gdt.CPU0`.
*   `.DeltaTime`: Time since last frame. **Clamp invalid values:** `if dt <= 0 or dt > 0.1 then dt = 1/60 end`.
*   `.Time`: Total simulation time elapsed (seconds).
*   `os.clock()`: High-precision timer (seconds). **(Confirmed Available)**
*   `math.randomseed()`: Use `gdt.CPU0.Time` or `os.clock()` for seeding, as `os.time()` is unavailable.
*   **Manual Timers:** Use `timer = timer - dt` in `update()`.

**Input Handling:**

*   **Stick (`gdt.StickN`):** `.X`, `.Y` (-100 to 100). Normalize/Invert as needed.
*   **DPad (`gdt.DPadN`):** `.X`, `.Y` (-100, 0, 100). Use edge detection (compare vs previous state).
*   **Button (`gdt.ButtonN`, `gdt.LedButtonN`):** `.ButtonDown` for press, `.ButtonState` for hold.
*   **KeyboardChipN / GamepadChipN:** Generate detailed events received via `eventChannelN`. Inspect the `arg` table for fields like `KeyCode`, `Char`, `ButtonName`, `AxisValue`, `IsPressed`. **(Confirmed)**

**Drawing (VideoChip API - `gdt.VideoChipN`):**

*   Reference: `local _vc = gdt.VideoChip0`. Dimensions: `_vc.Width`, `_vc.Height`.
*   **Functions (Documented):** `:Clear`, `:SetPixel`, `:DrawLine`, `:DrawCircle`, `:FillCircle`, `:DrawRect`, `:FillRect`, `:DrawTriangle`, `:FillTriangle`, `:DrawSprite`, `:DrawCustomSprite`, `:RasterSprite`, `:RasterCustomSprite`, `:DrawText`, `:DrawPointGrid`, `:DrawRenderBuffer`, `:RasterRenderBuffer`, `:SetPixelData`, `:BlitPixelData`.
*   **Coordinates:** Use `vec2(x, y)`. Use `math.floor()` for integers.
*   **Performance:** Can handle thousands (~10k tested) of simple draw calls (e.g., `FillRect`) per frame at 60 FPS on typical hardware. Performance degrades with complexity/count. **(Observed)**
*   **Render Targets:** `:RenderOnScreen()`, `:RenderOnBuffer(index)`.

**Networking (Wifi API - `gdt.WifiN`):**

*   **Permissions:** Requires user permission. Check `gdt.Wifi0.AccessDenied`.
*   **Asynchronous:** Requests are non-blocking. Responses via `eventChannelN`.
*   **Setup:** Connect Wifi output channel to Lua Controller input channel in editor. Implement matching `function eventChannelN(sender, response)`.
*   **Request Methods (Return `handle` number):** `:WebGet(url)`, `:WebPutData(url, data_str)`, `:WebPostData(url, data_str)`, `:WebPostForm(url, form_table)`, `:WebCustomRequest(url, method, headers_table, contentType, contentData)`.
*   **Control:** `:WebAbort(handle)`, `:GetWebUploadProgress(handle)`, `:GetWebDownloadProgress(handle)`.
*   **Cookies:** `:ClearCookieCache()`, `:ClearUrlCookieCache(url)`.
*   **Response Event (`WifiWebResponseEvent`):** `response` table contains `RequestHandle`, `ResponseCode`, `IsError`, `ErrorType`, `ErrorMessage`, `ContentType`, `Text` (UTF-8 body), `Data` (raw binary body as string - requires external libs or manual parsing if `buffer` is unavailable).
*   **Handling:** Check `response.IsError`, then `response.ResponseCode`. Use `response.Text` or `response.Data`. Match `RequestHandle`. Use state flags while waiting.

**Data Types:**

*   **`vec2` / `vec3`:** Built-in. Access `.X`, `.Y`, `.Z`. Arithmetic. **NO built-in methods**. **(Confirmed)**
*   **`color` Objects:**
    *   **Built-in Constants:** **Only the following 10 constants are available:** `color.black`, `color.blue`, `color.clear` (transparent black), `color.cyan`, `color.gray`, `color.green`, `color.magenta`, `color.red`, `color.white`, `color.yellow`. Use directly where a color object is needed. **(Confirmed by Docs & Testing)**
    *   **Other Colors:** Any other colors (e.g., orange, purple, lime, dark gray, specific shades) **MUST** be created using constructors.
    *   **Constructors (Use for custom colors):**
        *   `Color(r, g, b)` (RGB 0-255)
        *   `ColorRGBA(r, g, b, a)` (RGBA 0-255, Alpha `a` 0=transparent, 255=opaque. Alpha required).
        *   `ColorHSV(h, s, v)` (Hue [0-360], Sat [0-100], Val [0-100]).
    *   **Define Colors:** `local MY_ORANGE = ColorRGBA(255, 165, 0, 255)` or `local MY_RED = color.red`.
*   **Assets:** `SpriteSheet`, `AudioSample` (from `gdt.ROM`).
*   **Lua Types:** Standard (`string`, `number`, `boolean`, `table`, `function`, `nil`, `userdata`). `thread` exists.

**Vector Math (Manual Implementation REQUIRED):**

*   Need helpers for length, normalization, etc.
    ```lua
    local function vec2Length(v) return math.sqrt((v.X or 0)^2 + (v.Y or 0)^2) end
    local function vec2Normalize(v) local len=vec2Length(v); return (len>1e-4) and vec2(v.X/len,v.Y/len) or vec2(0,0) end
    ```

**Luau Syntax Extensions:** [Same as v16 - Literals, continue, compound assign, if-expr, iterators, floor div]

**Type Annotations:** [Same as v16 - Optional syntax]

**Standard Libraries (Available Globally):**

*   **Globals:** `assert`, `error`, `print`, `pairs`, `ipairs`, `pcall`, `xpcall`, `type`, `tostring`, `tonumber`, `next`, `select`, `rawequal`, `rawget`, `rawset`, `getmetatable`, `setmetatable`, etc.
*   **`math`:** Standard functions + `noise`, `clamp`, `sign`, `round`, `lerp`. Constants `pi`, `huge`.
*   **`table`:** Standard functions + `create`, `find`, `clear`, `freeze` (shallow), `isfrozen`, `clone`, `pack`, `unpack`, `move`.
*   **`string`:** Standard functions + `split`, `pack`, `packsize`, `unpack`.
*   **~~`coroutine`~~:** **Unavailable.** **(Confirmed)**
*   **`bit32`:** Bitwise operations.
*   **`utf8`:** UTF-8 support.
*   **`os`:** **Only `os.clock()` confirmed available.** (`os.time`, `os.date`, `os.difftime` **are unavailable**). **(Confirmed)**
*   **`debug`:** `info`, `traceback`. **(Likely restricted)**.
*   **~~`buffer`~~:** **Unavailable.** **(Confirmed)**

**External Libraries (`require`):**

*   Place `.lua` files in project's `lua` subfolder.
*   Use `local myLib = require("myLib.lua")`.
*   Use `pcall(require, ...)` for safe loading.
*   Sandboxed: Cannot access arbitrary system paths. **(Confirmed)**
*   Needed for tasks like JSON parsing or complex binary data handling.

**Object-Oriented Programming:** Via metatables.

**Accessing Assets (`gdt.ROM`):**

*   System: `gdt.ROM.System.SpriteSheets["AssetName"]`
*   User: `gdt.ROM.User.SpriteSheets["AssetName.png"]`, `gdt.ROM.User.AudioSamples["SampleName.wav"]`

**Persistence (`FlashMemoryN` API - `gdt.FlashMemoryN`):**

*   **Properties:**
    *   `.Size` (number): Total capacity in bytes (Read-only). (Small: 4096, Medium: 32768, Large: ~256000).
    *   `.Usage` (number): Currently used bytes (Read-only).
*   **Methods:**
    *   `:Save(table)` (boolean): Saves `table` data. Returns `true` on success, `false` otherwise.
    *   `:Load()` (table): Returns previously saved table, or `nil` if empty/cleared.
    *   `:Clear()`: Erases saved data.
*   **Data Limitations:** **Only reliably saves basic Lua types (number, string, boolean, nil) and nested tables containing ONLY these types.** Functions, userdata (`vec2`, assets), etc., will likely NOT be saved correctly (become `nil` on load). **(Confirmed via Testing)**
*   **Usage:** Check `.Usage == 0` or if `.Load()` returns `nil` to initialize default data on first run/after clear.

**Common Patterns:** State machines, timers (`dt` accumulation), edge detection, safety checks (`if obj then`), backwards loops for removal.

**Error Handling & Debugging:**

*   **Uncaught Errors:** **Halt script execution.** Use `pcall`. **(Confirmed)**
*   **`pcall`:** Use `pcall(function() ... end)` proactively around code that might fail. Returns `status, result_or_error`. **(Confirmed)**
*   **Debugging:** `print()`, `debug.traceback()`, draw debug info to screen (using valid `color.X` constants or constructors!).

**Known Limitations/Restrictions:**

*   No `goto`.
*   Restricted/Unavailable Libraries: `coroutine`, `io`, `buffer`, most of `os` (except `clock`), likely most of `debug`. **(Confirmed)**
*   No built-in Vector methods **(Confirmed)**.
*   Only 10 built-in `color.X` constants; others require constructors **(Confirmed)**.
*   Shallow `table.freeze` **(Confirmed)**.
*   FlashMemory has data type and size limitations **(Confirmed)**.
*   `onInit` runs only on script load/sim start, not PowerButton activation **(Confirmed)**.

--- END OF FILE Retrogadget Lua Scripting Cheat Sheet v17.txt ---