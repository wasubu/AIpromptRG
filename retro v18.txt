--- START OF FILE Retrogadget Lua Scripting Cheat Sheet v18.txt ---

Retrogadget Lua Scripting Cheat Sheet (v18 - API Signatures, onInit, Button Types)

**Goal:** To provide reliable guidelines for generating Lua code compatible with the Retrogadget environment, based on documentation, confirmed working examples, and direct user testing/feedback.

**Environment:**

*   **Engine:** Retrogadget Game
*   **Language:** Luau (based on Lua 5.1 syntax, with specific extensions detailed below).
*   **Execution Context:** Scripts run attached to a Lua Controller component.

**Core Script Structure & Execution:**

1.  **Main Script File:** Code resides in a Lua script file.
2.  **Execution Flow:**
    *   **Top Level:** Code runs **once** on script load / simulation start. Used for `require`, constants, initial definitions. Best place for setup that doesn't rely on `gdt` components being fully ready.
    *   **`onInit()`:** Optional callback function. **Intended** to be called **once** automatically ONLY on initial script load / simulation start (after top-level code). **User Experience Note:** Testing indicates `onInit()` may **NOT reliably run automatically** in all situations (e.g., script reloads, complex gadget starts). **Consider performing essential one-time setup either at the top level (if no component access needed) or within `update()` using a flag** (e.g., `local initialized = false; function update(dt) if not initialized then --[[ do setup here ]] initialized = true end ... end`). `onInit()` **definitely does NOT run when powering on via a PowerButton component.**
    *   **`update(dt)`:** Optional callback function. Called **repeatedly** every frame while the gadget simulation is running and powered (if applicable). Main loop for logic, input, drawing. Receives delta time (`dt`) as an argument.
    *   **`eventChannelN(sender, arg)`:** Optional callback functions. Called automatically when data arrives on the corresponding input channel of the Lua Controller (configured in the editor, e.g., from Wifi, KeyboardChip, GamepadChip).
3.  **Power-On Logic (with PowerButton):** To run code specifically when a gadget is powered *on* using a `PowerButton`, check for state changes of `gdt.PowerButtonN.PowerState` within the `update()` loop.
4.  **Initialization Strategy:** Due to `onInit()` reliability concerns, a common robust pattern is:
    ```lua
    local initialized = false
    local _vc = nil -- Declare component vars at top level

    local function performInitialization()
        if initialized then return end
        print("Performing one-time initialization...")
        _vc = gdt.VideoChip0 -- Get component refs here
        -- Other setup...
        initialized = true
        print("Initialization complete.")
    end

    function update(dt)
        performInitialization() -- Call this at the start of update
        if not initialized then return end -- Don't run rest of update if init failed

        -- Ensure dt is valid (see Time section)
        if type(dt) ~= "number" or dt <= 0 or dt > 0.1 then dt = 1 / 60 end

        -- Main update logic...
    end
    ```

**Accessing Gadget Components (`gdt`):**

*   Components accessed via global `gdt` table.
*   Reference by **editor name** (case-sensitive, e.g., `gdt.VideoChip0`, `gdt.Wifi0`, `gdt.FlashMemory0`, `gdt.LedButton0`).
    *   **Exception:** `LcdDisplay` components are referenced as `gdt.LcdN` (e.g., `gdt.Lcd0`).
*   **Component Discovery:** Use `pairs(gdt)` to iterate over attached components.
*   **Documented Component Types (Examples):** Input (AnalogStick, DPad, LedButton...), Output (LcdDisplay, Led, Screen...), Misc (AudioChip, CPU, ROM, VideoChip, Wifi, FlashMemory...). **Note:** Plain `ButtonN` type may not exist; use `LedButtonN`.
*   **Direct Property Access:** Use dot notation (e.g., `.Value`, `.Text`, `.LedState`, `.AccessDenied`, `.Usage`).
*   **Methods:** Use colon notation (e.g., `_vc:Clear()`, `fm:Save()`).

**Common Component APIs:**

*   **`VideoChipN`:** See **Drawing**. `.Width`, `.Height`.
*   **`SliderN`:** `.Value` (0-100).
*   **`LedButtonN`:** `.ButtonState` (boolean, true if held), `.ButtonDown` (boolean, true only on the frame it's pressed), `.LedState` (read/write boolean). **(Note: `ButtonN` may not be a valid type).**
*   **`DPadN`:** `.X`, `.Y` (-100, 0, 100).
*   **`CPUN`:** `.DeltaTime`, `.Time`.
*   **`AudioChipN`:** `:SetChannelVolume()`, `:Play()`, `:IsPlaying()`.
*   **`LcdN`:** **(LcdDisplay type)** `.Text` (write).
*   **`ScreenN`:** `.Width`, `.Height`, `.Offset`.
*   **`WifiN`:** See **Networking**. `.AccessDenied` (read-only boolean).
*   **`FlashMemoryN`:** See **Persistence**. `.Size` (bytes, read-only), `.Usage` (bytes, read-only).
*   **`PowerButtonN`:** `.PowerState` (boolean, read-only).

**Time & Frame Rate:**

*   Use `gdt.CPU0`.
*   `.DeltaTime`: Time since last frame (passed as `dt` argument to `update`). **Robust Check Recommended:** `if type(dt) ~= "number" or dt <= 0 or dt > 0.1 then dt = 1 / 60 end` (Handles potential `nil` or invalid values).
*   `.Time`: Total simulation time elapsed (seconds). Good for seeding random.
*   `os.clock()`: **Unavailable.**
*   `math.randomseed()`: Use `gdt.CPU0.Time` for seeding (e.g., `math.randomseed(gdt.CPU0.Time)`). `os.time()` is also unavailable.
*   **Manual Timers:** Use `timer = timer - dt` in `update()`.

**Input Handling:**

*   **Stick (`gdt.StickN`):** `.X`, `.Y` (-100 to 100). Normalize/Invert as needed.
*   **DPad (`gdt.DPadN`):** `.X`, `.Y` (-100, 0, 100). Use edge detection (compare vs previous state).
*   **LedButton (`gdt.LedButtonN`):** `.ButtonDown` for press event, `.ButtonState` for hold state.
*   **KeyboardChipN / GamepadChipN:** Generate detailed events received via `eventChannelN`. Inspect the `arg` table for fields like `KeyCode`, `Char`, `ButtonName`, `AxisValue`, `IsPressed`. **(Confirmed)**

**Drawing (VideoChip API - `gdt.VideoChipN`):**

*   Reference: `local _vc = gdt.VideoChip0`. Dimensions: `_vc.Width`, `_vc.Height`.
*   **Functions (Documented Signatures - Critical):**
    *   `:Clear(color color)`
    *   `:SetPixel(position vec2, color color)`
    *   `:DrawLine(position1 vec2, position2 vec2, color color)`
    *   `:DrawCircle(center vec2, radius number, color color)`
    *   `:FillCircle(center vec2, radius number, color color)`
    *   `:DrawRect(position1 vec2, position2 vec2, color color)`: Draws outline between two opposite corners.
    *   `:FillRect(position1 vec2, position2 vec2, color color)`: Fills rectangle between two opposite corners. **(Note signature!)**
    *   `:DrawTriangle(position1 vec2, position2 vec2, position3 vec2, color color)`
    *   `:FillTriangle(position1 vec2, position2 vec2, position3 vec2, color color)`
    *   `:DrawSprite(spriteSheet SpriteSheet, spriteIndex number, position vec2, color color, flags number)`
    *   `:DrawCustomSprite(spriteSheet SpriteSheet, spriteIndex number, position vec2, size vec2, color color, flags number)`
    *   `:RasterSprite(...)` *(Parameters likely similar to DrawSprite)*
    *   `:RasterCustomSprite(...)` *(Parameters likely similar to DrawCustomSprite)*
    *   `:DrawText(position vec2, fontSprite SpriteSheet, text string, textColor color, backgroundColor color)`: Draws text using a font spritesheet. Requires a `SpriteSheet` asset (e.g., `gdt.ROM.System.SpriteSheets["StandardFont"]`) and a background color (use `color.clear` for transparency). **(Note specific signature & font requirement!)**
    *   *(Other functions like :DrawPointGrid, :DrawRenderBuffer, etc. - Verify signatures if used)*
*   **Coordinates:** Use `vec2(x, y)`. Use `math.floor()` for integer coordinates when drawing.
*   **Performance:** Can handle thousands (~10k tested) of simple draw calls per frame. Varies with complexity.
*   **Render Targets:** `:RenderOnScreen()`, `:RenderOnBuffer(index)`.

**Networking (Wifi API - `gdt.WifiN`):** 
*   **Permissions:** Requires user permission. Check `gdt.Wifi0.AccessDenied`.
*   **Asynchronous:** Requests are non-blocking. Responses via `eventChannelN`.
*   **Setup:** Connect Wifi output channel to Lua Controller input channel in editor. Implement matching `function eventChannelN(sender, response)`.
*   **Request Methods (Return `handle` number):** `:WebGet(url)`, `:WebPutData(url, data_str)`, `:WebPostData(url, data_str)`, `:WebPostForm(url, form_table)`, `:WebCustomRequest(url, method, headers_table, contentType, contentData)`.
*   **Control:** `:WebAbort(handle)`, `:GetWebUploadProgress(handle)`, `:GetWebDownloadProgress(handle)`.
*   **Cookies:** `:ClearCookieCache()`, `:ClearUrlCookieCache(url)`.
*   **Response Event (`WifiWebResponseEvent`):** `response` table contains `RequestHandle`, `ResponseCode`, `IsError`, `ErrorType`, `ErrorMessage`, `ContentType`, `Text` (UTF-8 body), `Data` (raw binary body as string - requires external libs or manual parsing if `buffer` is unavailable).
*   **Handling:** Check `response.IsError`, then `response.ResponseCode`. Use `response.Text` or `response.Data`. Match `RequestHandle`. Use state flags while waiting.


**Data Types:**

*   **`vec2` / `vec3`:** Built-in. Access `.X`, `.Y`, `.Z`. Arithmetic. **NO built-in methods**. **(Confirmed)**
*   **`color` Objects:**
    *   **Built-in Constants:** **Only 10 available:** `color.black`, `color.blue`, `color.clear`, `color.cyan`, `color.gray`, `color.green`, `color.magenta`, `color.red`, `color.white`, `color.yellow`. **(Confirmed)**
    *   **Other Colors:** **MUST** use constructors.
    *   **Constructors:** `Color(r, g, b)`, `ColorRGBA(r, g, b, a)`, `ColorHSV(h, s, v)`. **(Use these for custom colors!)**
    *   **Define:** `local MY_ORANGE = ColorRGBA(255, 165, 0, 255)`
*   **Assets:** `SpriteSheet`, `AudioSample` (from `gdt.ROM`).
*   **Lua Types:** Standard (`string`, `number`, `boolean`, `table`, `function`, `nil`, `userdata`). `thread` exists.

**Vector Math (Manual Implementation REQUIRED):**
*   Need helpers for length, normalization, etc.
    ```lua
    local function vec2Length(v) return math.sqrt((v.X or 0)^2 + (v.Y or 0)^2) end
    local function vec2Normalize(v) local len=vec2Length(v); return (len>1e-4) and vec2(v.X/len,v.Y/len) or vec2(0,0) end
    ```

**Luau Syntax Extensions:** 
*   **Type Literals:** `true`, `false`, `nil`, `123`, `0xFACE`, `3.1415`, `1e-5`, `"hello"`, `[[world]]`
*   **`continue`:** Skips to the next iteration of a loop (`while`, `repeat`, `for`).
*   **Compound Assignments:** `a += 1`, `a -= 1`, `a *= 2`, `a /= 2`, `a %= 3`, `a^= 2`, `a ..= "s"`
*   **If Expressions:** `local value = if condition then expr1 else expr2`
*   **Generalized Iterators:** `for k, v in pairs(t)` and `for i, v in ipairs(a)` work as standard.
*   **Floor Division:** `x // y` performs integer division (`math.floor(x / y)`).

**Type Annotations:** 
*   Optional syntax for type checking (uses `:`).
    ```lua
    local score: number = 0
    local position: vec2 = vec2(10, 20)
    local function add(a: number, b: number): number return a + b end
    ```

**Standard Libraries (Available Globally):**

*   **Globals:** Standard Lua globals (`pairs`, `ipairs`, `pcall`, etc.).
*   **`math`:** Standard functions + `noise`, `clamp`, `sign`, `round`, `lerp`. Constants `pi`, `huge`.
*   **`table`:** Standard functions + `create`, `find`, `clear`, `freeze`, `isfrozen`, `clone`, `pack`, `unpack`, `move`.
*   **`string`:** Standard functions + `split`, `pack`, `packsize`, `unpack`.
*   **~~`coroutine`~~:** **Unavailable.** **(Confirmed)**
*   **`bit32`:** Bitwise operations.
*   **`utf8`:** UTF-8 support.
*   **`os`:** **Largely unavailable.** Functions like `os.clock()`, `os.time()`, `os.date()`, `os.difftime()` are **unavailable**. Use `gdt.CPU0.Time` for time-related seeding. **(User feedback/testing indicates `os.clock` is unavailable)**
*   **`debug`:** `info`, `traceback`. **(Likely restricted)**.
*   **~~`buffer`~~:** **Unavailable.** **(Confirmed)**

**External Libraries (`require`):**
*   Place `.lua` files in project's `lua` subfolder.
*   Use `local myLib = require("myLib.lua")`.
*   Use `pcall(require, ...)` for safe loading.
*   Sandboxed: Cannot access arbitrary system paths. **(Confirmed)**
*   Needed for tasks like JSON parsing or complex binary data handling.

**Object-Oriented Programming:** Via metatables.

**Accessing Assets (`gdt.ROM`):**

*   Requires a `ROM` component attached to the gadget.
*   System Font: `gdt.ROM.System.SpriteSheets["StandardFont"]` (Needed for `_vc:DrawText`)
*   User SpriteSheet: `gdt.ROM.User.SpriteSheets["AssetName.png"]`
*   User Audio: `gdt.ROM.User.AudioSamples["SampleName.wav"]`

**Persistence (`FlashMemoryN` API - `gdt.FlashMemoryN`):**
*   **Properties:**
    *   `.Size` (number): Total capacity in bytes (Read-only). (Small: 4096, Medium: 32768, Large: ~256000).
    *   `.Usage` (number): Currently used bytes (Read-only).
*   **Methods:**
    *   `:Save(table)` (boolean): Saves `table` data. Returns `true` on success, `false` otherwise.
    *   `:Load()` (table): Returns previously saved table, or `nil` if empty/cleared.
    *   `:Clear()`: Erases saved data.
*   **Data Limitations:** **Only reliably saves basic Lua types (number, string, boolean, nil) and nested tables containing ONLY these types.** Functions, userdata (`vec2`, assets), etc., will likely NOT be saved correctly (become `nil` on load). **(Confirmed via Testing)**
*   **Usage:** Check `.Usage == 0` or if `.Load()` returns `nil` to initialize default data on first run/after clear.

**Common Patterns:** State machines, timers (`dt` accumulation), edge detection (`.ButtonDown`), safety checks (`if obj then`), backwards loops for removal, robust initialization (see Core Script Structure).

**Error Handling & Debugging:**

*   **Uncaught Errors:** **Halt script execution.** Use `pcall`. **(Confirmed)**
*   **`pcall`:** Use `pcall(function() ... end)` proactively. Returns `status, result_or_error`. **(Confirmed)**
*   **Debugging:** `print()`, `debug.traceback()`, draw debug info to screen (using correct `DrawText` with font, or geometric shapes).

**Known Limitations/Restrictions:**

*   No `goto`.
*   Restricted/Unavailable Libraries: `coroutine`, `io`, `buffer`, most of `os` (including `clock`, `time`), likely most of `debug`. **(Confirmed)**
*   No built-in Vector methods **(Confirmed)**.
*   Only 10 built-in `color.X` constants; others require constructors **(Confirmed)**.
*   Specific, non-standard API signatures for drawing functions like `DrawText` and `FillRect` **(Confirmed)**.
*   `onInit()` may not run automatically; requires careful initialization strategy **(User Confirmed)**.
*   `gdt.ButtonN` likely unavailable, use `gdt.LedButtonN` **(User Confirmed)**.
*   FlashMemory has data type and size limitations **(Confirmed)**.

--- END OF FILE Retrogadget Lua Scripting Cheat Sheet v18.txt ---